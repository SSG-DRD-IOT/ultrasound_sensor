## Programming Sensors with Legacy C vs MRAA, UPM

In this part, we would like to compare how MRAA abstraction and UPM sensor library helps developers to reuse code and develop applications using sensors without any replication of legacy code.

For the sake of timing, we picked a simple sensor working on GPIO pins to address actual process. In this example we will use HC-SR04 Ultrasound sensor, used in college courses to teach students for distance measuring using speed of sound and will use UP2 board.

HC-SR04 sensor has 4 pins, VCC, GND, TRIG and ECHO pins. Actual working principle of sensor is that, when triggered a sound wave is generated by sensor and when it echoed back, it estimates the distance with the speed of sound.

Connecting HC-SR04 to UP2 Board Pins:
https://www.electroschematics.com/8902/hc-sr04-datasheet/

Image-1: HC-SR04 Sensor



Image-2: Electronics of HC-SR04 Sensor



We need two GPIO pins, I will use PIN 13-15 from UP2 GP-Bus Expansion.

In Linux SYSFS:
- PIN 13 corresponds to GPIO 432
- PIN 15 corresponds to GPIO 431

See UP2 board pinout: https://wiki.up-community.org/Pinout_UP2

So let's write our code to read distance continuously from HC-SR4 sensor and print the distance in centimeters until you press 'q' or 'Q':

Basic logic of code is :
Set mode of GPIO pins for TRIG and ECHO pins
Toggle TRIG pin for 10us
Measure the us for ECHO PIN get HIGH
Calculate Distance with formula (duration (uS) / 59.0) in centimeters

Logic is simple but, in order to play with GPIO pins, I had developed 4 methods:
gpio_set_mode
gpio_export
gpio_get_value
gpio_set_value

### Code Block:
```
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <sys/time.h>

#define TRIG_PIN 431 //MRAA NO 7, PIN 15 on UP2 board
#define ECHO_PIN 432 //MRAA NO 13, PIN 13 on UP2 board

#define HIGH 1
#define LOW 0

#define INPUT "in"
#define OUTPUT "out"

#define BUF 8
#define MAX_BUF 256

const int TriggerDuration = 10; // trigger duration

const double distanceConstant = 59.0;// uS constant as datasheet pointed

const double minDistance = 2.00; //cms limits of sensor
const double maxDistance = 400.00; //cms

/**
 * Export Given GPIO
 * @param gpio_num
 * @return
 */
int gpio_export(int gpio_num) {
    //Device File Path Declarations
    const char* gpio_export = "/sys/class/gpio/export";
    //Device File Declarations
    int fd_x = 0, g_err = -1;
    //Buffer
    char g_buf[BUF];
    fd_x = open(gpio_export, O_WRONLY);
    if (fd_x < 0) {
        printf("Couldn't get export FD\n");
        return g_err;
    }
    //Export GPIO Pin
    sprintf(g_buf, "%d", gpio_num);
    if (write(fd_x, g_buf, sizeof(g_buf)) == g_err) {
        printf("Couldn't export GPIO %d\n", gpio_num);
        close(fd_x);
        return g_err;
    }
    close(fd_x);
    return 0;
}

/**
 * GPIO Mode Set Method
 * @param gpio_num
 * @param mode
 * @return
 */
int gpio_set_mode(int gpio_num, const char* mode) {
    //Device Direction File Path Declarations
    const char* gpio_direction_path = "/sys/class/gpio/gpio%d/direction";
    //Device File Declarations
    int fd_d = 0, g_err = -1;
    //Buffers
    char pindirection_buf[MAX_BUF];
    char d_buf[BUF];
    //Set pin number and set gpio path
    if (sprintf(pindirection_buf, gpio_direction_path, gpio_num) < 0) {
        printf("Can't create pin direction file path\n");
        return g_err;
    }
    //Open GPIO Direction File
    fd_d = open(pindirection_buf, O_WRONLY);
    //If GPIO doesn't exist then export gpio pins
    if (fd_d < 0) {
        if (gpio_export(gpio_num) < 0) {
            return g_err;
        }
        fd_d = open(pindirection_buf, O_WRONLY);
        if (fd_d <= 0) {
            printf("Couldn't get direction File for pin %d\n", gpio_num);
            return g_err;
        }
    }
    sprintf(d_buf, mode);
    if (write(fd_d, d_buf, sizeof(d_buf)) == g_err) {
        printf("Couldn't set direction for pin %d\n", gpio_num);
        return g_err;
    }
    close(fd_d);
    return 0;
}

/**
 * GPIO Set Value
 * @param gpio_num integer gpio number in linux
 * @param value integer LOW/HIGH to set
 * @return success/error
 */
int gpio_set_value(int gpio_num, int value) {
    //Device Direction File Path Declarations
    const char* gpio_value_path = "/sys/class/gpio/gpio%d/value";
    //Device File Declarations
    int fd_v = 0, g_err = -1;
    //Buffers
    char pinvalue_buf[MAX_BUF];
    char v_buf[BUF];
    //Set pin number and set gpio path
    if (sprintf(pinvalue_buf, gpio_value_path, gpio_num) < 0) {
        printf("Can't create pin direction file path\n");
        return g_err;
    }
    //Open GPIO Value File
    fd_v = open(pinvalue_buf, O_WRONLY);
    //If GPIO doesn't exist then export gpio pins
    if (fd_v < 0) {
        if (gpio_export(gpio_num) < 0) {
            return g_err;
        }
        fd_v = open(pinvalue_buf, O_WRONLY);
        if (fd_v <= 0) {
            printf("Couldn't get value File for pin %d\n", gpio_num);
            return g_err;
        }
    }
    sprintf(v_buf, "%d", value);
    if (write(fd_v, v_buf, sizeof(v_buf)) == g_err) {
        printf("Couldn't set value for pin %d\n", gpio_num);
        return g_err;
    }
    close(fd_v);
    return 0;
}

/**
 * Get current value of GPIO
 * @param gpio_num integer gpio number in linux
 * @return HIGH/LOW
 */
int gpio_get_value(int gpio_num) {
    //Device Direction File Path Declarations
    const char* gpio_value_path = "/sys/class/gpio/gpio%d/value";
    //Device File Declarations
    int fd_v = 0, g_err = -1;
    //Buffers
    char pinvalue_buf[MAX_BUF];
    char v_buf[BUF];
    //Set pin number and set gpio path
    if (sprintf(pinvalue_buf, gpio_value_path, gpio_num) < 0) {
        printf("Can't create pin direction file path\n");
        return g_err;
    }
    //Open GPIO Value File
    fd_v = open(pinvalue_buf, O_RDONLY);
    //If GPIO doesn't exist then export gpio pins
    if (fd_v < 0) {
        if (gpio_export(gpio_num) < 0) {
            return g_err;
        }
        fd_v = open(pinvalue_buf, O_RDONLY);
        if (fd_v <= 0) {
            printf("Couldn't get value File for pin %d\n", gpio_num);
            return g_err;
        }
    }
    if (read(fd_v, v_buf, 1) == g_err) {
        printf("Couldn't get value for pin %d\n", gpio_num);
        return g_err;
    }
    close(fd_v);
    return atoi(v_buf);
}

int main() {
    //Set GPIO PIN MODES
    gpio_set_mode(TRIG_PIN, OUTPUT);
    gpio_set_mode(ECHO_PIN, INPUT);

    char ch;

    //start distance calculation
    do{
        printf("Calculating New Distance .... \n");
        //Set Trigger Pin HIGH
        gpio_set_value(TRIG_PIN, HIGH);
        //wait for trigger duration
        usleep(TriggerDuration);
        //Set Trigger Pin LOW
        gpio_set_value(TRIG_PIN, LOW);

        struct timeval start;
        struct timeval end;

        int echo = 0;
        int counter = 0;
        gettimeofday(&start, NULL);

        long cycleLength = (1000000 * start.tv_sec) + start.tv_usec + 70000;
        long sampleTime = 0;

        //wait till echo pin gets low
        while (sampleTime < cycleLength) {
            echo = gpio_get_value(ECHO_PIN);
            if (echo == 1 && counter == 0) {
                gettimeofday(&start, NULL);
                counter++;
            } else if (echo == 0 && counter == 1) {
                gettimeofday(&end, NULL);
                break;
            } else {
                sampleTime = (1000000 * start.tv_sec) + start.tv_usec;
            }
        }

        double s = (double) start.tv_sec * 1000000 + (double) start.tv_usec;
        double e = (double) end.tv_sec * 1000000 + (double) end.tv_usec;

        double distance = (e - s) / distanceConstant;

        printf("New Distance: ");
        if ( distance > maxDistance) {
            printf("%f centimeters\n", maxDistance);
        } else if ( distance < minDistance) {
            printf("%f centimeters\n", maxDistance);
        } else {
            printf("%f centimeters\n", distance);
        }

        //wait 2 seconds
        sleep(2);

        ch = getchar();
    }while(ch != 'q' && ch != 'Q');

    return 0;
}
```

### Build Run Instruction:
```
$ cd legacy_sys/
$ gcc ultrasound.c -o Ultrasound
 ```
or
```
$ mkdir build
$ cmake ../
$ make all

$ sudo ./Ultrasound
 ```

What if we wanted to use MRAA?

There wouldn't be any need for reinventing the wheel, so we can just use the MRAA methods:
```
mraa_gpio_init
mraa_gpio_dir
mraa_gpio_write
mraa_gpio_read
```
to play with GPIO. Need to change to MRAA's own Pin Numbering instead of SYSFS GPIO Numbers.

see : https://github.com/intel-iot-devkit/mraa/blob/master/docs/up2.md

### Code Block


### Build and Run Instructions
```
$ gcc ultrasound_upm.c -o UltrasoundMRAA -I/usr/include/mraa/ -L/usr/lib/x86_64-linux-gnu/ -lmraa
```
or 
```
$ mkdir build
$ cmake ../
$ make all

$ sudo ./UltrasoundMRAA
 ```

What if we skip MRAA and just use UPM which already have HC-SR04 sensor in its library?

UPM library already does sensor initialisation so no need to access for GPIO pins when we defined the PIN numbers.

### Code Block



### Build and Run Instructions
```
$ gcc ultrasound_upm.c -o UltrasoundUPM -I/usr/include/upm/ -L/usr/lib/x86_64-linux-gnu/ -lmraa -lupmc-hcsr04
```
or 
```
$ mkdir build
$ cmake ../
$ make all

$ sudo ./UltrasoundUPM
 ```
